---
presentation:
  width: 800
  height: 600
  theme: beige.css
---

<!-- slide -->

〜 ファーストサークル全課題解説フェス 〜
### push_swap 編

<!-- slide -->

本題の前に
軽く自己紹介

<!-- slide -->

@import "icon.jpg" {width="132px" height="120px"}

- エラブ タカヤ(ID:terabu、愛称:ラブ)
- Piscine:2022-08 / 入学:2022-10
- 校舎出現率：週 5
- 職業：無職
- 特記事項：
  自分から声をかけるのは苦手ですが、
  声をかけてくれると喜びます

<!-- slide -->

### 本題

<!-- slide -->

### 前半

1. 課題の概要
2. 何から始めるのか
3. クリアまでの道筋

<br />
<br />

### 後半

push_swap で考える分割統治法(再帰)

<!-- slide -->

### 前半

<!-- slide -->

1. 課題の概要
2. 何から始めるのか
3. クリアまでの道筋

→ これらをまとめた資料が既に存在しています

<!-- slide -->

[push_swap を 理解するためのスライド](https://docs.google.com/presentation/d/1c2PU6ZST7uMwNHl6aAz2WsJ5QFf1J7JJsMkW0VSTXc8/edit#slide=id.p)

created by nafuka さん

<!-- slide -->

### クリアまでの道筋（補足）

<!-- slide -->

基本方針
小さく始めよう！

<!-- slide -->

何はともあれ
2 個のケースから

<!-- slide -->

1.  ３個ケースの補足
2.  ６個以下ケースの補足
3.  ７個以上ケースについて
4.  入力チェックを忘れずに

<!-- slide -->

1️⃣ ３個ケースの補足

<!-- slide -->

6 パターン

- 1 2 3 -> x (ソート済み)
- 1 3 2 -> 2 1 3 ( rra ) -> 1 2 3 ( sa )
- 2 1 3 -> 1 2 3 ( sa )
- 2 3 1 -> 1 2 3 ( rra )
- 3 1 2 -> 1 2 3 ( ra )
- 3 2 1 -> 2 1 3 ( ra ) -> 1 2 3 ( sa )

<!-- slide -->

2️⃣ ６個以下ケースの補足

<!-- slide -->

なぜ 6 個？

<!-- slide -->

- レビューで局所最適化が求められる
- ３個ケースが流用できる丁度良い数

<!-- slide -->

3️⃣ ７個以上ケースについて

<!-- slide -->

データ構造とアルゴリズムを選択

<!-- slide -->

データ構造の種類

- 配列
- 単方向リスト
- 双方向リスト(循環・非循環)

<!-- slide -->

[push_swap で考えるデータ構造](https://speakerdeck.com/love42/42tokyo-push-swap-data-structure)
created by terabu

<!-- slide -->

アルゴリズムの種類

- 基数ソート
- クイックソート(系)
- 独自アルゴリズム(push_swap 特化型)

<!-- slide -->

クイックソート「系」とした理由

<!-- slide -->

- 人によって実装・分割の仕方が微妙に違う
- 課題の要件上、本来のクイックソートとは異なるものになる
  - 領域が 2 つのみ
  - 命令の制約

<!-- slide -->

クイックソートを選択する場合は
ソート前に座標圧縮をするのがオススメ！

<!-- slide -->

座標圧縮とは

<!-- slide -->

それぞれの要素が

「全体で何番目に小さいか」

を求めていく作業

<!-- slide -->

例

```text
8, 100, 33, 12, 6, 1211
```

↓

```text
1, 4, 3, 2, 0, 5
```

<!-- slide -->

なぜ必要？

<!-- slide -->

ピボット(分割の軸)を

決めるのが楽になる

<!-- slide -->

クイックソート（分割統治法）の手法
→ 後半でお話しします

<!-- slide -->

4️⃣ 入力チェックを忘れずに

<!-- slide -->

- 引数が 0, 1 個
- 整数外（1 a 2）
- int 外（2147483648 -2147483649）
- ソート済み（1 2 3）
- 重複している（3 2 2 1）
- etc...

<!-- slide -->

入力チェックの考慮漏れが原因で
落とされるケースがほとんどです

（課題をちゃんと読みましょう！）

<!-- slide -->

前半のまとめ

- 「push_swap を 理解するためのスライド」を読もう！
- 小さく始めてみよう！

<!-- slide -->

前半は以上となります
ありがとうございました！

<!-- slide -->

### 後半

<!-- slide -->

push_swap で考える分割統治法(再帰)

<!-- slide -->

何を話すのか？

<!-- slide -->

「push_swap を 理解するためのスライド」

分割統治法(クイックソート)を深掘り

<!-- slide -->

何故話すのか？

<!-- slide -->

- 自分が躓いたところ
- アルゴリズムのエッセンスが詰まっている

<!-- slide -->

解説の前に

<!-- slide -->

良いスコアを目指す内容ではありません 🙇‍♂️

<!-- slide -->

解説始めます！

<!-- slide -->

### 解説の流れ

1. 処理の流れを考えよう！
2. 具体的な値で試してみよう！
3. 機能ごとに整理しよう！
4. 再帰部分＆パラメーターに注目しよう！
5. （時間があれば）コードを見てみよう！

<!-- slide -->

1️⃣ 処理の流れを考えよう！

<!-- slide -->

簡易フローチャート

@import "qsort-flow.svg" {width="1200px" height="480px"}

<!-- slide -->

2️⃣ 具体的な値で試してみよう！

<!-- slide -->

分割の条件

- 分割できる：B が４個以上の時
- 分割できない：B が３個以下の時

<!-- slide -->

A の要素半分を B に移動
@import "qsort-div_start.svg" {width="1000px" height="520px"}

<!-- slide -->

１ ２ ３をソートして確定
@import "qsort-div123.svg" {width="1200px" height="520px"}

<!-- slide -->

４ ５をソートして確定

@import "qsort-div45.svg" {width="1000px" height="400px"}

<!-- slide -->

６ ７をソートして確定

@import "qsort-div67.svg" {width="1000px" height="400px"}

<!-- slide -->

８ ９をソートして確定

@import "qsort-div89.svg" {width="1000px" height="400px"}

<!-- slide -->

3️⃣ 機能ごとに整理しよう！

<!-- slide -->

@import "qsort-func.svg" {width="1600px" height="560px"}

<!-- slide -->

ポイントは？

<!-- slide -->

A → B で
何個戻せば良いか
↓
A に push した数量を
どうやって戻すか

<!-- slide -->

例えば、16 → 8 → 4 → 2 で分割されたら
2 → 4 → 8 → 16 の順で戻す必要がある

<div style="font-size: 20px;">
※正確には 4、8、16 で戻したらそれぞれでさらに分割されるのでもっと複雑
</div>

<!-- slide -->

解決方法

1. 再帰関数
2. スタック領域

<!-- slide -->

今回は再帰関数で考えます

<!-- slide -->

ところで皆さん

<!-- slide -->

再帰関数は苦手ですか？

<!-- slide -->

ハーイ！

🙋‍♂️🙋🙋‍♂️🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋
🙋🙋‍♂️🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️
🙋‍♂️🙋🙋‍♂️🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋🙋‍♂️🙋
<!-- slide -->

再帰のおさらい

<!-- slide -->

再帰関数の例

@import "recursive.c"
<!-- slide -->

処理の流れと printf の結果

@import "qsort-recur_standard.svg" {width="600px" height="440px"}

<!-- slide -->

「戻る」という性質を活用して
A にいくつ push したか記録する

<!-- slide -->

どう実現させるか？

<!-- slide -->

B → A(分割)と A → B(戻す)という処理を
1 つの関数にまとめて再帰させる

<!-- slide -->

<div style="font-size:16px;">（再喝）</div>
@import "qsort-func.svg" {width="1600px" height="560px"}

<!-- slide -->

4️⃣ 再帰＆パラメーターに注目しよう！

<!-- slide -->

@import "qsort-recur_btoa.svg" {width="1200px" height="560px"}

<!-- slide -->

5️⃣ （時間があれば）コードを見てみよう！

<!-- slide -->

後半のまとめ

分割統治法の実現方法について
ざっくりした処理フロー → コード化まで

<!-- slide -->

今回、一番伝えたかったこと

<!-- slide -->

いろんな切り口で考えてみよう！

- 処理の流れは？
- 具体的な値を入れてみたらどう動く？
- 抽象化・共通化できる部分はある？
- パラメーターはどのように変化する？

<!-- slide -->

質疑応答
（...時間があれば）

<!-- slide -->

ご清聴ありがとうございました！
